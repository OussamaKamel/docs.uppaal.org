[{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/declarations/","title":"Declarations","tags":[],"description":"","content":"Declarations are either global or local (to a template) and can contain declarations of clocks, bounded integers, channels (although local channels are useless), arrays, records, and types. The syntax is described by the grammar for Declarations:\nDeclarations ::= (VariableDecl | TypeDecl | [Function] | [ChanPriority])* VariableDecl ::= [Type] VariableID (\u0026#39;,\u0026#39; VariableID)* \u0026#39;;\u0026#39; VariableID ::= ID [ArrayDecl]* [ \u0026#39;=\u0026#39; Initialiser ] Initialiser ::= [Expression] | \u0026#39;{\u0026#39; Initialiser (\u0026#39;,\u0026#39; Initialiser)* \u0026#39;}\u0026#39; TypeDecls ::= \u0026#39;typedef\u0026#39; Type ID ArrayDecl* (\u0026#39;,\u0026#39; ID ArrayDecl*)* \u0026#39;;\u0026#39; The global declarations may also contain at most one channel priority declaration.\nExamples  const int a = 1;\nconstant a with value 1 of type integer. bool b[8], c[4];\ntwo boolean arrays b and c, with 8 and 4 elements respectively. int[0,100] a=5;\nan integer variable with the range [0, 100] initialised to 5. int a[2][3] = { { 1, 2, 3 }, { 4, 5, 6} };\na multidimensional integer array with default range and an initialiser. clock x, y;\ntwo clocks x and y. chan d;\na channel. urgent chan e;\nan urgent channel.  struct { int a; bool b; } s1 = { 2, true }; an instantiation of the structure from above where the members a and b are set to 2 and true. meta int swap;\nint a;\nint b;\nassign swap = a; a = b; b = swap;\na meta variable is used to swap the contents of two integers.  Type Declarations The typedef keyword is used to name types.\nExample The following declares a record type S containing an integer a, a boolean b and a clock c:\ntypedef struct { int a; bool b; clock c; } S; "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/menu-bar/file/","title":"File Menu","tags":[],"description":"","content":"The leftmost menu of the menu bar is the file menu. It is mainly used to open and save (part of) system descriptions or requirement specifications created in UPPAAL. The available items are:\n New System: re-initiates the editor with an empty system. Open System: loads an existing system from file. The corresponding requirement specification (i.e. same file name but with the suffix .q) is loaded into the verifier, if it exists. Save System: saves the system in the editor to file. Save System As: saves the system in the editor to a specified file. Import Template: imports template(s) from an existing system description. A dialog window is shown which allows a subset of the available templates to be imported. Export Template: exports the currently edited template in Encapsulated Postscript format to file. New Queries: re-initiates the requirement specification editor with an empty file. Open Queries: loads an existing set of requirement specifications from file. Save Queries: saves the requirement specifications in the editor to file. Save Queries As: saves the requirement specifications in the editor to a specified file name. Exit: exits UPPAAL.  "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/yggdrasil/traces/","title":"Generating Traces","tags":[],"description":"","content":"Traces are generated using three purposes: queries, depth search, and individual edges.\nIn the Verifier tab the existential queries (E\u0026lt;\u0026gt;) can be used to specify a desired functionality to be tested and hence can be selected as a test purpose for test case generation. All or specific queries can be selected and the resulting trace is added to be used as a test case.\nThe second option uses heuristics of random depth first search of the specified number of steps with a hope of increasing the coverage. The resulting trace is used as a test case. The search process is repeated until the newly generated trace does not contribute new coverage over the previous traces. In order to use this method a global integer variable named reach must be declared, initialized to zero and should not be used anywhere in the model.\nThe third option attempts to cover the remaining edges which are not covered by the previously generated traces. This method submits a separate reachability query for each uncovered edge. Large models may have many edges, and therefore many queries may take a long time to execute. Even worse: some edges might be unreachable at all and thus require exhaustive search which may consume a lot of time and memory. In order to use this method a global integer variable named single must be declared, initialized to zero and should not be used throughout the model.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/","title":"GUI Reference","tags":[],"description":"","content":"Chapter 1 GUI Reference Discover the UPPAAL gui.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/expressions/identifiers/","title":"Identifiers","tags":[],"description":"","content":"The valid identifier names are described by the following regular expression: [a-zA-Z_]([a-zA-Z0-9_])*\nExamples  a, B, c2, d2\nvalid identifier names. 1, 2a, 3B, 4c5\ninvalid identifier names.  "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/templates/locations/","title":"Locations","tags":[],"description":"","content":"Locations of a timed automaton are graphically represented as circles. If a timed automaton is considered as a directed graph, then locations represent the vertices of this graph. Locations are connected by edges.\nNames Locations can have an optional name. Besides serving as an identifier allowing you to refer to the location from the requirement specification language, named locations are useful when documenting the model. The name must be a valid identifier and location names share the name space with variables, types, templates, etc.\nInvariants Locations are labelled with invariants. Invariants are expressions and thus follow the abstract syntax of expressions. However, the type checker restricts the set of possible expressions allowed in invariants.\nAn invariant must be a conjunction of simple conditions on clocks, differences between clocks, and boolean expressions not involving clocks. The bound must be given by an integer expression. Furthermore lower bounds on clocks are disallowed. It is important to understand that invariants influence the behaviour of the system \u0026ndash; they are distinctly different from specifying safety properties in the requirements specification language. States which violate the invariants are undefined; by definition, such states do not exist. This influences the interpretation of urgent channels and broadcast channels. Please see the section on synchronisations for a detailed discussion of this topic.\nIn addition, stop-watches are supported and they are declared with invariants. Clock rate expressions are specified and they are part of the conjunction in the invariant. Furthermore, the forall construct is accepted in invariants to ease use of arrays.\nStatistical model checker supports any integer expression as a clock rate which allows modeling costs.\nRate of Exponential  The rate of exponential is a ratio expression which specifies the rate of exponential probability distribution. The rate expression can be a simple integer expression or two integer expressions separated by a colon like r:q where the rate is determined as ratio r/q.\nThe rate of exponential is used in a statistical model checking. If the location does not have an invariant over time, then it is assumed that the probability of leaving the location is distributed according to the exponential distribution: Pr(leaving after t)=1−e−λt, where e=2.718281828…, t is time and λ is the fixed rate. Probability density of the exponential distribution is λe−λt and thus intuitively λ means the probability density of leaving at time zero, i.e. as soon as some edge is enabled. The smaller the rate is specified, the longer the delay is preferred.\nThe generation of exact delay relies on pseudo random number generator and on 32-bit architectures the longest possible delay is rather limited: ln(231)/λ ≈ 21.49/λ.\nExamples The following are valid invariants. Here x and y are clocks and i is an integer array.\n x \u0026lt;= 2\nx is less than or equal to 2. x \u0026lt; y\nx is (strictly) less than y. (i[0]+1) != (i[1]*10) forall(i:int[0,2]) x[i] \u0026lt;= 3\nThe clocks x[0], x[1], and x[2] of the clock array are less or equal to 3. forall(i:int[0,2]) y[i]' == b[i]\nThe clock rates y[0]', y[1]', and y[2]' are set to, respectively, b[0], b[1], and b[2]. Note that the only valid values are 0 and 1. Setting the rate to 0 effectively stops a clock (makes it a stop-watch). In statistical model checking the rate is allowed to be any integer value (can be interpreted as continuous cost).  Initial locations Each template must have exactly one initial location. The initial location is marked by a double circle.\nUrgent locations Urgent locations freeze time; i.e. time is not allowed to pass when a process is in an urgent location.\nSemantically, urgent locations are equivalent to:\n adding an extra clock, x, that is reset on every incomming edge, and adding an invariant x \u0026lt;= 0 to the location.  Committed locations Like urgent locations, committed locations freeze time. Furthermore, if any process is in a committed location, the next transition must involve an edge from one of the committed locations.\nCommitted locations are useful for creating atomic sequences and for encoding synchronization between more than two components. Notice that if several processes are in a committed location at the same time, then they will interleave.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/menu-bar/","title":"Menu Bar","tags":[],"description":"","content":"The menu bar is located in the upper part of the main window or at the top of the screen. It contains the following menu items:\n File Menu   Edit Menu   View Menu   Tools Menu   Options Menu   Help Menu   "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/system-editor/navigation-tree/","title":"Navigation Tree","tags":[],"description":"","content":"The navigation tree is shown in the left panel of the system editor. It is used for accessing the various components of a system description. A node in the tree can be double clicked to view (or hide) the sub tree of the node.\nThe root of the navigation tree is named Project if the system is unnamed, otherwise the name of the system (i.e. the name of the XML-file).\nThe sub node Declarations is used for declarations of global scope. They can be referred to directly in template declarations.\nEach process template of the system description is represented by a node placed under the root node of the navigation tree. When this node is selected (i.e. clicked) the automaton becomes available for editing in the right panel of the system editor. Each template has a sub node named Declarations that is used for typing in local declarations and documentation comments.\nThe remaining sub node of the root, named System declarations is used for further declarations, process assignments, and the system declaration.\nNote: the navigation tree can be opened in a separate window using the \u0026ldquo;Drag out\u0026rdquo; button. The window returns to its original position when it is closed. The same effect can be obtained by clicking with the left mouse button while pressing the Alt key.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/requirements-specification/semantics/","title":"Semantics of the Requirement Specification Language","tags":[],"description":"","content":"In the following we give a pseudo-formal semantics for the requirement specification language of UPPAAL. We assume the existence of a timed transition system (S, s0, →) as defined in the semantics of UPPAAL. In the following, p and q are state properties for which we define the following temporal properties:\nPossibly The property E\u0026lt;\u0026gt; p evaluates to true for a timed transition system if and only if there is a sequence of alternating delay transitions and action transitions _s0_→_s1→…→_sn, where s0 is the initial state and sn satisfies p.\nInvariantly The property A[] p evaluates to true if (and only if) every reachable state satisfy p.\nAn invariantly property A[] p can be expressed as the possibly property not E\u0026lt;\u0026gt; not p.\nPotentially always The property E[] p evaluates to true for a timed transition system if and only if there is a sequence of alternating delay or action transitions _s0_→_s1_→…→_si_→… for which p holds in all states si and which either:\n is infinite, or ends in a state (Ln, vn) such that either  for all d: (Ln, vn+d) satisfies p and Inv(Ln), or there is no outgoing transition from (Ln, vn)    Eventually The property A\u0026lt;\u0026gt; p evaluates to true if (and only if) all possible transition sequences eventually reaches a state satisfying p.\nAn eventually property A\u0026lt;\u0026gt; p can be expressed as the potentially property not E[] not p.\nLeads To The syntax p \u0026ndash;\u0026gt; q denotes a leads to property meaning that whenever p holds eventually q will hold as well. Since UPPAAL uses timed automata as the input model, this has to be interpreted not only over action transitions but also over delay transitions.\nA leads to property p \u0026ndash;\u0026gt; q can be expressed as the property A[] (p imply A\u0026lt;\u0026gt; q).\nState Properties Any side-effect free expression is a valid state property. In addition it is possible to test whether a process is in a particular location and whether a state is a deadlock. State proprerties are evaluated for the initial state and after each transition. This means for example that a property A[] i != 1 might be satisfied even if the value of i becomes 1 momentarily during the evaluation of initializers or update-expressions on edges.\nLocations Expressions on the form P.ℓ, where P is a process and ℓ is a location, evaluate to true in a state (L, v) if and only if P.ℓ is in L.\nDeadlocks The state property deadlock evaluates to true for a state (L, v) if and only if for all d ≥ 0 there is no action successor of (L, v + d).\nStatistical Properties UPPAAL can estimate the probability of expression values statistically. There are four types of statistical properties: quantitative, qualitative, comparison and probable value estimation.\nProbability Estimation (Quantitative Model Checking) \u0026lsquo;Pr[\u0026rsquo; ( Clock | \u0026lsquo;#\u0026rsquo; ) \u0026lsquo;\u0026lt;=\u0026rsquo; CONST \u0026lsquo;](\u0026rsquo; ('\u0026lt;\u0026gt;' | \u0026lsquo;[]') Expression \u0026lsquo;)'\nQuantitative query estimates the probability of a path expression being true given that the predicate in probability brackets is true. Intuitively the model exploration is bounded by an expression in the brackets: it can be limited by setting the bound on a clock value, model time or the number of steps (discrete transitions).\nThe result is an estimated probability (with ε confidence interval specified in statistical parameters) and a number of histograms over the values of the variable specified in the probability brackets. Note that histograms omit runs that do not satisfy the property.\nHypothesis Testing (Qualitative Model Checking) \u0026lsquo;Pr[\u0026rsquo; ( Clock | \u0026lsquo;#\u0026rsquo; ) \u0026lsquo;\u0026lt;=\u0026rsquo; CONST \u0026lsquo;](\u0026rsquo; ('\u0026lt;\u0026gt;\u0026rsquo; | \u0026lsquo;[]') Expression \u0026lsquo;)\u0026rsquo; ('\u0026lt;='|'\u0026gt;=') PROB\nHypothesis testing checks whether the probability of a property is less or greater than specified bound. The query is more efficient than probability estimation as it is one sided and requires fewer simulations to attain the same level of significance.\nProbability Comparison \u0026lsquo;Pr[\u0026rsquo; ( Variable | \u0026lsquo;#\u0026rsquo; ) \u0026lsquo;\u0026lt;=\u0026rsquo; CONST \u0026lsquo;](\u0026rsquo; ('\u0026lt;\u0026gt;\u0026rsquo; | \u0026lsquo;[]') Expression \u0026lsquo;)\u0026rsquo; ('\u0026lt;='|'\u0026gt;=') \u0026lsquo;Pr[\u0026rsquo; ( Variable | \u0026lsquo;#\u0026rsquo; ) \u0026lsquo;\u0026lt;=\u0026rsquo; CONST \u0026lsquo;](\u0026rsquo; ('\u0026lt;\u0026gt;\u0026rsquo; | \u0026lsquo;[]') Expression \u0026lsquo;)'\nCompares two probabilities indirectly without estimating them.\nValue Estimation \u0026lsquo;E[\u0026rsquo; ( Clock | \u0026lsquo;#\u0026rsquo; ) \u0026lsquo;\u0026lt;=\u0026rsquo; CONST \u0026lsquo;;\u0026rsquo; CONST \u0026lsquo;]\u0026rsquo; \u0026lsquo;(\u0026rsquo; (\u0026lsquo;min:'|\u0026lsquo;max:\u0026rsquo; Expression \u0026lsquo;)'\nEstimates the value of an expression by running a given number of simulations.\nExamples  Pr[Train.Cross) estimates the probability of the process Train reaching the location Cross within 100 model time units. The tool will produce a number of histograms over model time, like probability density distribution of Train.Cross becoming true over model time, thus allowing to inspect what the most likely moment in time is when the train arrives at crossing. Pr[costPlane.Landing) estimates the probability of the process Plane reaching the location Landing within 1000 cost units where clock variable cost has various rates in different locations. The tool will produce a number of histograms over the cost values, like a probability density distribution of Plane.Landing becoming true over cost, thus allowing to inspect what the most likely cost is when the plane lands.  Property Equivalences The UPPAAL requirement specification language supports five types of properties, which can be reduced to two types as illustrated by the following table.\n   Name Property Equivalent to   Possibly E p    Invariantly A[] p not E not p   Potentially always E[] p    Eventually A p not E[] not p   Leads to p -- q A[] (p imply A q)    "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/concrete-simulator/simulation-control/","title":"Simulation Control","tags":[],"description":"","content":"The simulation control is the left panel of the simulator. It is used to control the simulation and to select the state or transition to be visualized in the others panels of the simulator. The control panel is divided in two parts:\nThe upper part is used for performing step-by-step simulation. The Transition chooser area is a clickable area where vertical axis displays the active transitions at this location and horizontal axis displays the time at which the transition will be ﬁred. The time interval where a transition is enabled and the time interval where a transition is selectable are colored in different way. The time interval in which a transition can be fired (where the transition is selectable) is delimited by markers: one small circle at the beginning and one at the end of the interval (full if it is close, empty if it is open). When the mouse move to a selectable area, the color of the interval become brighter. By clicking one can select a specific transition and a specific time for firing the transition. The selected transition will be highlighted. The time selected is displayed in the Delay-combo box. One can also specified directly the time in the Delay-combo, once the transition has been selected. If one click in a non-selectable zone of a transition, the tool chooses the closest valid time. The Reset Delay-button is used to reset the delay to zero. Pressing the Take transition-button causes the simulated system to fire the selected transition at the specified time. The Reset-button is used to reset the simulated system to its initial state.\nThe lower part of the control panel, the Simulation Trace area, has a view displaying the generated trace. The displayed trace is an alternating sequence of control location vectors and transitions. The simulation always progresses from the highlighted element in this view. It is possible to change the selection using the mouse.\nThe Simulation Trace area contains a combo box that displays the current time (according to the hightlighted state in the trace) and the following buttons:\n First: highlights the first element in the trace. Last: highlights the last element in the trace. Prev: highlights the element immediately preceding the current selection (if any) in the trace. Next: highlights the element immediately following the current selection (if any) in the trace. Play: replays the trace starting from the currently selected element. Random: starts a random simulation where the simulator proceed automatically by randomly selecting enabled transitions at random time.  The slider is used to control the speed used when traces are replayed and when random simulation is performed.\nKeyboard Shortcuts    Key Shortcut to   Q Correspond to the button Prev.   A Correspond to the button Next.   P Correspond to the button Replay.   R Correspond to the button Random.   F Correspond to the button First.   L Correspond to the button Last.    "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/verifier/specifying/","title":"Specifying Requirements","tags":[],"description":"","content":"An overview of the system requirements (called queries below and in the GUI) is shown in the panel named Overview of the verifier. The toggle button Comments/Queries is used to control if the queries or the comments are to be shown in the overview.\nQueries are selected and de-selected using the mouse alone, or in combination with the Shift or the Control key of the keyboard (use the Shift key to (de-)select a range of entries and the Control key to (de-)select single entries). The first selected requirement and its comment is always shown in the two editor fields named Query and Comment, where they may be edited.\nNew entries are added using the button named Insert. A new entry is inserted before the first selected entry, or appended after the last entry if no entry is selected.\nThe button named Remove is used for deleting selected entries in the overview. Nothing is deleted if no entries are selected.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/","title":"System Description","tags":[],"description":"","content":"A system model in UPPAAL consists of a network of processes described as extended timed automata. The description of a model consist of three parts: its global and local declarations, the automata templates, and the system definition.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/system-definition/template-instantiation/","title":"Template Instantiation","tags":[],"description":"","content":"New templates can be defined from existing templates using the grammar for Instantiation. The new template has the same automaton structure and the same local variables as the template it is defined from. However, arguments are provided for any formal parameters of the template, thus changing the interface of the template.\nInstantiation ::= ID [ \u0026#39;(\u0026#39; [Parameters] \u0026#39;)\u0026#39; ] \u0026#39;=\u0026#39; ID \u0026#39;(\u0026#39; [Arguments] \u0026#39;)\u0026#39; \u0026#39;;\u0026#39; Template instantiation is most often used to bind formal parameters to actual arguments. The resulting template is later instantiated into a process by listing it in the system line.\nThe new template can itself be parameterised. This provides the opportunity to make a partial instantiation of a template, where some formal parameters are bound while others remain free. Examples of typical uses are listed below.\nFor more examples, see the example systems included in the UPPAAL distribution.\nExamples Renaming P1 = Q(); P2 = Q(); system P1, P2; Q is a template without any formal parameters. P1 and P2 become templates identical to Q. This is used to make several instances of Q with different names. Notice that P1=Q() is a shorthand of P1()=Q().\nBinding parameters In this example we use the textual syntax for template declaration as used in the XTA format. In the GUI, these templates would be defined graphically.\nprocess R(int \u0026amp;i, const int j) { ... } int x; S = R(x, 1); system S; Here we bind the formal parameters of R, i and j, to x and 1 respectively. S becomes a template without any parameters. When listed in the system line, S is instantiated into a process with the same name.\nPartial instantiation In this example we use the textual syntax for template declaration as used in the XTA format. In the GUI, these templates would be defined graphically.\nprocess P(int \u0026amp;x, int y, const int n, const int m) { ... } int v, u; const struct { int a, b, c; } data[2] = { { 1, 2, 3 }, { 4, 5, 6 } }; Q(int \u0026amp;x, const int i) = P(x, data[i].a, data[i].b, 2 * data[i].c); Q1 = Q(v, 0); Q2 = Q(u, 1); system Q1, Q2; Here P is a template with four formal parameters integer parameters. The first must be passed by reference, the remaining by value. Q is a template with two formal integer parameters. The first must be passed by reference, the second by value. Q1 is equivalent to P(v, data[0].a, data[0].b, 2 * data[0].c.\nThis is very convenient when defining many instances of the same template with almost the same arguments. It is also useful to bind some formal parameters and leave others free. When the resulting template is listed in the system line, UPPAAL will create a process for each possible combination of arguments to the free parameters.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/declarations/types/","title":"Types","tags":[],"description":"","content":"There are 6 predefined types: int, bool, clock, chan, double and string. Array and record types can be defined over all types except string.\nType ::= Prefix TypeId Prefix ::= \u0026#39;urgent\u0026#39; | \u0026#39;broadcast\u0026#39; | \u0026#39;meta\u0026#39; | \u0026#39;const\u0026#39; TypeId ::= ID | \u0026#39;int\u0026#39; | \u0026#39;clock\u0026#39; | \u0026#39;chan\u0026#39; | \u0026#39;bool\u0026#39; | \u0026#39;double\u0026#39; | \u0026#39;string\u0026#39; | \u0026#39;int\u0026#39; \u0026#39;[\u0026#39; [Expression] \u0026#39;,\u0026#39; [Expression] \u0026#39;]\u0026#39; | \u0026#39;scalar\u0026#39; \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; | \u0026#39;struct\u0026#39; \u0026#39;{\u0026#39; FieldDecl (FieldDecl)* \u0026#39;}\u0026#39; FieldDecl ::= Type ID ArrayDecl* (\u0026#39;,\u0026#39; ID ArrayDecl*)* \u0026#39;;\u0026#39; ArrayDecl ::= \u0026#39;[\u0026#39; [Expression] \u0026#39;]\u0026#39; | \u0026#39;[\u0026#39; Type \u0026#39;]\u0026#39; The default range of an integer is [-32768, 32767]. Any assignment out of range will cause the verification to abort.\nVariables of type bool can have the values false and true, which are equivalent to the the integer values 0 and 1. Like in C, any non-zero integer value evalutes to true and 0 evaluates to false.\nChannels can be declared as urgent and/or broadcast channels. See the section on synchronisations for information on urgent and broadcast channels.\nFloating-point variables of the double-type behave like C-doubles. Certain restriction applies to the use of doubles in symbolic contexts.\nVariables of string type must be declared constant. The primary use of string variables is in combination with External Functions\nConstants Integers, booleans, doubles strings, and arrays and records over integers and booleans can be marked constant by prefixing the type with the keyword const.\nMeta variables Integers, booleans, doubles, and arrays and records over integers and booleans can be marked as meta variables by prefixing the type with the keyword meta.\nMeta variables are stored in the state vector, but are sematically not considered part of the state. I.e. two states that only differ in meta variables are considered to be equal.\nArrays The size of an array is specified either as an integer or as a bounded integer type or scalar set type. In the first case the array will be 0-indexed. In the latter case, the index will be of the given type. The following declares a scalar set s_t of size 3 and an integer array a of size 3 indexed by the scalar:\ntypedef scalar[3] s_t; int a[s_t];  Record Variables Record types are specified by using the struct keyword, following the C notation. For example, the record s below consist of the two fields a and b:\nstruct { int a; int b; } s;  Scalars Scalars in UPPAAL are integer like elements with a limitted number of operations: Assignment and identity testing. Only scalars from the same scalar set can be compared.\nThe limitted number of operations means that scalars are unordered (or that all orders are equivalent in the sense that the model cannot distinguish between any of the them). UPPAAL applies symmetry reduction to any model using scalars. Symmetry reduction can lead to dramatic reductions of the state space of the model. resulting in faster verification and less memory being used.\nNotice that symmetry reduction is not applied if diagnostic trace generation is enabled or when A\u0026lt;\u0026gt;, E[] or \u0026ndash;\u0026gt; properties are verified.\nScalar sets are treated as types. New scalar sets are constructed with the scalar[n] type constructor, where n is an integer indicating the size of the scalar set. Scalars of different scalar sets are incomparable. Use typedef to name a scalar set such that is can be used several times, e.g.\ntypedef scalar[3] mySet; mySet s; int a[mySet]; Here mySet is a scalar set of size 3, s is a variable whos value belongs to the scalar set mySet and a is an array of integers indexed by the scalar set mySet. Thus a[s] = 2 is a valid expression.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/toolsandapi/uppaal/","title":"UPPAAL","tags":[],"description":"","content":"UPPAAL can be executed from the command line using the following command on unix:\n uppaal [OPTION] \u0026hellip; [FILENAME]\n On windows, the following command can be used (for instance, using \u0026ldquo;Run\u0026rdquo; from the Start Menu):\n java -jar \\path\\uppaal.jar [OPTION] \u0026hellip; [FILENAME]\n where path is the complete path to the uppaal.jar file (it might also be necessary to specify the complete path to the java executable).\nThe optional filename refers to a model to be loaded at startup.\nThe available command line options are:\n --antialias on|off (default on) turns antialiasing on or off in the automata rendering. --engineName  The name of verification server (default is server on Unix and server.exe on Windows) to be used by the GUI. --enginePath  The path to the verification server (e.g. bin-Windows) to be used by the GUI. --help Displays a summary of options. --serverHost  Host name of remote machine running verification server. --serverPort  Port number used by verification server on remote machine. --splashScreen on|off Disables or enables the splash screen. Note that starting from Java 6 the only way to override or disable the splash screen is -splash java option, e.g. java -splash:/dev/null -jar uppaal.jar. --export templateName filename.ext Export the named template to a graphics file. The graphics format is determined by the filename extension, and EPS will be used instead if format is not recognized. Use system keyword to export all templates where the filenames will be taken from the template name. --psColors on|off Selects whether to export automata in color or greyscale EPS. "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/system-editor/drawing/","title":"Drawing","tags":[],"description":"","content":"The rightmost panel of the system editor is used for drawing automata. There are currently four drawing tools named Select, Location, Edge, and Nail represented by the buttons in the tool bar.\n Select tool: The select tool is used to select, move, modify and delete elements. Elements can be selected by clicking on them or by dragging a rubber band arround one or more elements. Elements can be added or removed from a selection by holding down the control key while clicking on the element. The current selection can be moved by dragging them with the mouse. Double clicking an element brings up the editor for that element. Right clicking an element brings up a pop-up menu from which properties of the element can be changed. It is possible to change the source and target of an edge by moving the mouse to the beginning or end of an edge until a small circle appears. Drag this circle to a new location in order to change the source or target of the edge. Location tool: The location tool is used to add new locations. Simply click with the left mouse button in order to add a new location. Branch tool: The branch tool is used to create probabilistic branches. Simply click with the left mouse button in order to add a new branch point, then choose edge tool to create connecting edges. Edge tool: The edge tool is used to add new edges between locations. Start the edge by clicking on the source location, then click in order to place nails and finally click the target location. The operation can be cancelled by pressing the right mouse button. Nail tool: The nail tool is used to add new nails to an edge. Simply click and drag anywhere on an edge to add and place a new nail.  For users with a three button mouse, the middle mouse button can be used to create new elements. The editor automatically chooses the correct tool: Clicking on an empty spot creates a new location, clicking on a location creates a new edge and clicking on an edge creates a new nail. With this feature it is possible to use the functionallity of all four tools without having to select the tools directly.\nColors The display color of individual locations and edges can be changed from the pop-up menu for these elements. UPPAAL does not assign any semantic meaning to the colors of locations and edges.\nComments Comments can be added to locations and edges. Double click the location or edge to bring up the editor for that element. The editor has a Comments tab for adding comments. UPPAAL does not assign any semantic meaning to the comments.\nWhen shown in the tooltip of an element, comments are interpreted as HTML, i.e. tags like \u0026lt;p\u0026gt; and \u0026lt;b\u0026gt; may be used for formating.\nTooltips A tooltip is shown when hovering the mouse over an automaton element. The tooltip contains useful information such as syntax errors.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/templates/edges/","title":"Edges","tags":[],"description":"","content":"Locations are connected by edges. Edges are annotated with selections, guards, synchronisations and updates. Edges may also have branches of possible destinations with their own updates and probabilistic weights.\n Selections Selections non-deterministically bind a given identifier to a value in a given range. The other three labels of an edge are within the scope of this binding. Guards An edge is enabled in a state if and only if the guard evaluates to true. Synchronisation Processes can synchronize over channels. Edges labelled with complementary actions over a common channel synchronise. Updates When executed, the update expression of the edge is evaluated. The side effect of this expression changes the state of the system. Weights Probabilistic branches .  Selections SelectList ::= ID \u0026#39;:\u0026#39; Type | SelectList \u0026#39;,\u0026#39; ID \u0026#39;:\u0026#39; Type For each ID in SelectList, bind ID non-deterministically to a value of type Type. The identifiers are available as variables within the other labels of this edge (guard, synchronization, or update). The supported types are bounded integers and scalar sets.\nNote: The identifiers will shadow any variables with the same names.\nExample select: i : int[0,3]\nsynchronization: a[i]?\nupdate expression: receive_a(i)\nThis edge will non-deterministically bind i to an integer in the range 0 to 3, inclusive. The value i is then used both as an array index when deciding what channel to synchronize on, and as an argument in the subsequent call to the function receive_a.\nGuards Guards follow the abstract syntax of expressions. However, the type checker restricts the set of possible expressions allowed in guards: A guard must be a conjunction of simple conditions on clocks, differences between clocks, and boolean expressions not involving clocks. The bound must be given by an integer expression.\nExamples  x \u0026gt;= 1 \u0026amp;\u0026amp; x \u0026lt;= 2\nx is in the interval [1,2]. x \u0026lt; y\nx is (strictly) less than y. (i[0]+1) != (i[1]*10)\nValue at position 0 in an integer array i plus one is not equal to value at position 1 times 10 (i must be an integer array since we use arithmetic operations on its elements).  \nSynchronisations Channels are used to synchronise processes. This is done by annotating edges in the model with synchronisation labels. Synchronisation labels are syntactically very simple. They are of the form e? or e!, where e is a side effect free expression evaluating to a channel.\nThe intuition is that two processes can synchronise on enabled edges annotated with complementary synchronisation labels, i.e. two edges in different processes can synchronise if the guards of both edges are satisfied, and they have synchronisation labels e1? and e2! respectively, where e1 and e2 evaluate to the same channel.\nWhen two processes synchronise, both edges are fired at the same time, i.e. the current location of both processes is changed. The update expression on an edge synchronizing on e1! is executed before the update expression on an edge synchronizing on e2?. This is similar to the kind of synchronisation used in CCS or to rendezvous synchronisation in SPIN.\nUrgent channels are similar to regular channels, except that it is not possible to delay in the source state if it is possible to trigger a synchronisation over an urgent channel. Notice that clock guards are not allowed on edges synchronising over urgent channels.\nBroadcast channels allow 1-to-many synchronisations. The intuition is that an edge with synchronisation label e! emits a broadcast on the channel e and that any enabled edge with synchronisation label e? will synchronise with the emitting process. I.e. an edge with an emit-synchronisation on a broadcast channel can always fire (provided that the guard is satisfied), no matter if any receiving edges are enabled. But those receiving edges, which are enabled will synchronise. Notice that clock guards are not allowed on edges receiving on a broadcast channel. The update on the emitting edge is executed first. The update on the receiving edges are executed left-to-right in the order the processes are given in the system definition.\nNotice that for both urgent and broadcast channels it is important to understand when an edge is enabled. An edge is enabled if the guard is satisfied. Depending on the invariants, the target state might be undefined. This does not change the fact that the edges are enabled! E.g. when two edges in two different processes synchronise via a broadcast channel, and the invariant of the target location of the receiving edge is violated, then this state is not defined. It is not the case that the emitting edge can be fired by itself since the receiving edge is enabled and thus must synchronise. Please see the section about the semantics for further details.\nUpdates An update is a comma separated list of expressions. These expressions will typically have side effects. Assignments to clocks are limited to the regular = assignment operator and only integer expressions are allowed on the right hand side of such assignments. The syntax of updates is defined by the grammar for Update:\nUpdate ::= [Expression (\u0026#39;,\u0026#39; Expression)*] Note: Assignments are evaluated sequentially (not concurrently). On synchronizing edges, the assignments on the !-side (the emitting side) are evaluated before the ?-side (the receiving side).\nThe regular assignment operator, =, can be used for assigning values to integer, boolean, record and clock variables. The other assignment operators are limitted to integer and boolean variables and work as in C, e.g. i += 2 is equivalent to i = i + 2 except that any side effect of evaluating i is only executed once in the first case whereas it is executed twice in the latter case.\nPlease remember that any integers are bounded. Any attempt to assign a value outside the declared range to an integer, will cause an error and the verification will be aborted.\nExamples  x = 0\nclock (or integer variable) x is reset. j = ( i[1]\u0026gt;i[2] ? i[1] : i[2] )\ninteger j is assigned the maximum value of array elements i[1] and i[2]. This is equivalent to j = i[1] \u0026gt;? i[2], except that one of the sub-expressions is evaluated twice in the example (once in the condition, and again in either the true case or the false case). x = 1, y=2*x\ninteger variable x is set to 1 and y to 2 (as assignments are interpreted sequentially).  Weights The weight over branch is a constant non-negative integer expressions denoting the probabilistic likely-hood of the branch being executed. The probability of a particular branch is determined as a ratio of its weight over the sum of weights of all branches emanating from the same branch node.\nThe weights are used in probabilistic and statistical model checking.\nExample select: i : int[0,3]\nupdate expression: gen_data(i)\nweight: w[i]\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/menu-bar/edit/","title":"Edit Menu","tags":[],"description":"","content":"The Edit menu offers a set of commands supported in the system editor. The items are:\n Undo: reverses the most recent editing action. This function is only available in the editor. Redo: re-applies the editing action that has most recently been reversed by the Undo action. This function is only available in the editor. Cut: removes the selected text and places it in the clipboard. There must be an active text selection. Copy: places a copy of the selected text in the clipboard. There must be an active text selection. Paste: places text in the clipboard at the cursor location in the currently active editor. There must be text in the clipboard, and an editor must be active. Delete: delete selected text. There must be an active text selection. Insert Template: adds a new empty template to the system description. Remove Template: removes the currently selected template from the system description. There must be a template selected.  "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/declarations/functions/","title":"Functions","tags":[],"description":"","content":"Functions can be declared alongside other declarations. The syntax for functions is defined by the grammar for Function:\nFunction ::= [Type] [ID] \u0026#39;(\u0026#39; [Parameters] \u0026#39;)\u0026#39; Block  Block\t::= \u0026#39;{\u0026#39; [Declarations] Statement* \u0026#39;}\u0026#39; Statement ::= Block | \u0026#39;;\u0026#39; | [Expression] \u0026#39;;\u0026#39; | ForLoop | Iteration | WhileLoop  | DoWhileLoop  | IfStatement  | ReturnStatement ForLoop\t::= \u0026#39;for\u0026#39; \u0026#39;(\u0026#39; [Expression] \u0026#39;;\u0026#39; [Expression] \u0026#39;;\u0026#39; [Expression] \u0026#39;)\u0026#39; Statement  Iteration\t::= \u0026#39;for\u0026#39; \u0026#39;(\u0026#39; [ID] \u0026#39;:\u0026#39; [Type] \u0026#39;)\u0026#39; Statement WhileLoop ::= \u0026#39;while\u0026#39; \u0026#39;(\u0026#39; [Expression] \u0026#39;)\u0026#39; Statement DoWhile ::= \u0026#39;do\u0026#39; Statement \u0026#39;while\u0026#39; \u0026#39;(\u0026#39; [Expression] \u0026#39;)\u0026#39; \u0026#39;;\u0026#39; IfStatment ::= \u0026#39;if\u0026#39; \u0026#39;(\u0026#39; [Expression] \u0026#39;)\u0026#39; Statement [ \u0026#39;else\u0026#39; Statement ] ReturnStatement ::= \u0026#39;return\u0026#39; [ [Expression] ] \u0026#39;;\u0026#39; Iterators The keyword for has two uses: One is a C/C++/Java like for-loop, and the other is a Java like iterator. The latter is primarily used to iterate over arrays indexed by scalars.\nA statement for (ID : Type) Statement will execute Statement once for each value ID of the type Type. The scope of ID is the inner expression Expr, and Type must be a bounded integer or a scalar set.\nExamples add The following function returns the sum of two integers. The arguments are call by value.\n int add(int a, int b) { return a + b; }  swap The following procedure swaps the values of two call-by-reference integer parameters.\nvoid swap(int \u0026amp;a, int \u0026amp;b) { int c = a; a = b; b = c; } initialize The following procedure initializes an array such that each element contains its index in the array. Notice that the an array parameter is a call-by-value parameter unless an ampersand is used in the declaration. This is different from C++ syntax, where the parameter could be considered an array of references to integer.\nvoid initialize(int\u0026amp; a[10]) { for (i : int[0,9]) { a[i] = i; } } "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/","title":"Language Reference","tags":[],"description":"","content":"Chapter 2 UPPAAL Language Reference "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/system-definition/progress-measures/","title":"Progress Measures","tags":[],"description":"","content":"A progress measure is an expression that defines progress in the model. It should be weakly monotonically increasing, although occasional decreasses are acceptable. E.g. sequence numbers used in communication protocols might be used to define a progress measure, provided that the sequence number does not overflow to often.\nIf progress measures are defined, UPPAAL uses the generalized sweepline method to reduce the memory usage. However to be efficient, the domain of a progress measure should not be too large - otherwise performance might degrade significantly.\nProgress measures are placed after the system definition. The syntax is defined by the grammar for ProgressDecl:\nProgressDecl ::= \u0026#39;progress\u0026#39; \u0026#39;{\u0026#39; ( [Expression] \u0026#39;;\u0026#39; )* \u0026#39;}\u0026#39; Examples int i, j, k; ... progress { i; j + k; } For the above to be a useful progress measure, i and j + k should increase weakly monotonically.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/requirements-specification/","title":"Requirements Specification","tags":[],"description":"","content":"In this help section we give a BNF-grammar for the requirement specification language used in the verifier of UPPAAL.\nProp ::= \u0026#39;A[]\u0026#39; Expression  | \u0026#39;E\u0026lt;\u0026gt;\u0026#39; Expression  | \u0026#39;E[]\u0026#39; Expression  | \u0026#39;A\u0026lt;\u0026gt;\u0026#39; Expression  | Expression --\u0026gt; Expression  | \u0026#39;sup\u0026#39; \u0026#39;:\u0026#39; List | \u0026#39;sup\u0026#39; \u0026#39;{\u0026#39; Expression \u0026#39;}\u0026#39; \u0026#39;:\u0026#39; List  | \u0026#39;inf\u0026#39; \u0026#39;:\u0026#39; List | \u0026#39;inf\u0026#39; \u0026#39;{\u0026#39; Expression \u0026#39;}\u0026#39; \u0026#39;:\u0026#39; List  | Probability | ProbUntil | Probability ( \u0026#39;\u0026lt;=\u0026#39; | \u0026#39;\u0026gt;=\u0026#39; ) PROB | Probability ( \u0026#39;\u0026lt;=\u0026#39; | \u0026#39;\u0026gt;=\u0026#39; ) Probability | Estimate  List ::= Expression | Expression \u0026#39;,\u0026#39; List  Probability ::= \u0026#39;Pr[\u0026#39; ( Clock | \u0026#39;#\u0026#39; ) \u0026#39;\u0026lt;=\u0026#39; CONST \u0026#39;]\u0026#39; \u0026#39;(\u0026#39; (\u0026#39;\u0026lt;\u0026gt;\u0026#39;|\u0026#39;[]\u0026#39;) Expression \u0026#39;)\u0026#39; ProbUntil ::= \u0026#39;Pr[\u0026#39; ( Clock | \u0026#39;#\u0026#39; ) \u0026#39;\u0026lt;=\u0026#39; CONST \u0026#39;]\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;U\u0026#39; Expression \u0026#39;)\u0026#39; Estimate ::= \u0026#39;E[\u0026#39; ( Clock | \u0026#39;#\u0026#39; ) \u0026#39;\u0026lt;=\u0026#39; CONST \u0026#39;;\u0026#39; CONST \u0026#39;]\u0026#39; \u0026#39;(\u0026#39; (\u0026#39;min:\u0026#39; | \u0026#39;max:\u0026#39;) Expression \u0026#39;)\u0026#39;  CONST is a non-negative integer constant. PROB is a floating point number from an interval [0;1] denoting probability. '#' means a number of simulation steps -- discrete transitions -- in the run. 'min:' means the minimum value over a run of the proceeding expression. 'max:' means the maximum value over a run of the proceeding expression.  All expressions are state predicates and must be side effect free. It is possible to test whether a certain process is in a given location using expressions on the form process.location. For sup properties, expression may not contain clock constraints and must evaluate to either an integer or a clock.\nSee also: Semantics of the Requirement Specification Language\nExamples  A[] 1\u0026lt;2\ninvariantly 1\u0026lt;2. E\u0026lt;\u0026gt; p1.cs and p2.cs\ntrue if the system can reach a state where both process p1 and p2 are in their locations cs. A[] p1.cs imply not p2.cs\ninvariantly process p1 in location cs implies that process p2 is not in location cs. A[] not deadlock\ninvariantly the process is not deadlocked. sup: list\nthe property is always true and returns the suprema of the expressions (maximal values in case of integers, upper bounds, strict or not, for clocks). sup{expression}: list\nThe expressions in the list are evaluated only on the states that satisfy the the expression (a state predicate) that acts like an observation. The inf formula are similar to sup but for infima. A state predicate should be used when a clock infimum is asked otherwise the trivial result is \u0026gt;= 0.  "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/yggdrasil/test-code/","title":"Specifying Test Code","tags":[],"description":"","content":"Traces are translated into executable test cases based on test code entered into the model. The test code is entered as verbatim text, so any language or execution back-end can be used. Test code can be entered in five areas: Prefix code, location enter code, location exit code, edge code, and postfix code. Each test case starts with the prefix code, continues with test code along the locations and edges of the trace and ends with the postfix code.\nThe prefix (and the postfix) code is entered as a comment after the system definition section using a special multi-line comment starting with the word TEST_PREFIX (and TEST_POSTFIX respectively).\nEach location in the transition system has two areas for test code. Double clicking a location in the editor will bring up a window with a test code tab. The location enter code is added to the test case when this location is entered, and the location exit code is added when the location is left.\nSimilarly double clicking an an edge will bring up a window with a single test code field. This code is added to the test case when the transition containing this edge is traversed.\nFor location and edge test code the value of variables can be entered into the test case. This is done using $(var) for global variables or $(Process.var) for process-local variables. Dollar signs can be escaped with backslash like $ and backslash can be escaped with backslash like \\. For location enter code the value is read after the transition into the state has been taken. For location exit code the value is read before the transition out of the state is taken. For edge code the value is read before taking the transition.\nThe test case file name and extension can be configured using special comments too: TEST_FILENAME and TEST_FILEEXT. These comments must be on one line. Generic name \u0026ldquo;testcase\u0026rdquo; and \u0026ldquo;.code\u0026rdquo; are used if these settings are not set.\nExample test case generation settings in the system declarations after the system definition:\n/** TEST_FILENAME test- */ /** TEST_FILEEXT .java */ /** TEST_PREFIX public class Test { public static int main(String[] args){ */ /** TEST_POSTFIX } } */ _Note the double star in the special multiline comment start, single space characters in the TEST_FILE* options and no other characters on the comment begin and end lines in the TEST_*FIX options._\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/templates/","title":"Templates","tags":[],"description":"","content":"UPPAAL provides a rich language for defining templates in the form of extended timed automata. In contrast to classical timed automata, timed automata in UPPAAL can use a rich expression language to test and update clock, variables, record types, call user defined functions, etc.\nThe automaton of a template consist of Locations and edges. A template may also have local declarations and parameters. A template is instantiated by a process assignment (in the system definition).\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/toolbar/","title":"Tool Bar","tags":[],"description":"","content":"The tool bar is normally located just below the menu bar but can be moved (using the mouse) to other positions or even to a separate window. The tool bar is devided into three groups. The two leftmost groups provides quick access to some of the most frequently used menu items. The rightmost group contains editing tools.\nThe first group contains the following buttons: New, Open Project, and Save. These features are described in the File menu section.\nThe second group contains the following buttons: Zoom to Fit, Zoom In, and Zoom Out. This features are described in the View menu section.\nThe third group contains tools used in the editor for selecting and moving elements of an automaton, and for adding locations, edges and nails. This features are described in the section on Drawing.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/concrete-simulator/variables/","title":"Variables Panel","tags":[],"description":"","content":"The variables panel is the middle panel of the simulator. It displays the values of the data and clock variables in the current state or transition selected in the trace of the simulation control panel.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/verifier/verifying/","title":"Verifying Requirements","tags":[],"description":"","content":"The queries (i.e. the system requirements) are verified from the verifier interface of UPPAAL. A verification is always performed according to the settings specified in the Options menu of the main menu bar.\nThe selected queries are verified when the button named Check is pressed. The verification progress dialog displays the progress of how many queries have been verified, what is the current load of a passed-waiting list, current processor time usage (the time spent for verification is in blue, the time spent by operating system is in red), current usage of host\u0026rsquo;s random access memory (verification memory is in blue, memory used by other running processes is in gray and operating system cache and buffers are in yellow), swap disk usage (swapped out verification is in blue, other is in grey). Note that resource figures do not include the overhead of UPPAAL GUI and command line utilities (like memtime run on verifyta) are more accurate. Some figures are not available on some OSes (system cache allocation is not documented on Windows API and swap usage per process is not maintained by Linux kernel), therefore they might not show up.\nThe verification output is displayed in the Status field at the bottom of the verifier panel. The result is also indicated by the circular markers in the rightmost column of the Overview panel. A grey marker indicates that the truth value of the property is unknown, a green marker that the property is satisfied, and a red marker that the property is not satisfied.\nIn case the Over Approximation or the Under Approximation options are enabled, the output of the verifier might be that property is \u0026ldquo;maybe satisfied\u0026rdquo;. This happens when the verifier cannot determine the truth value of the property due to the approximations used.\nStatistical Model Checking Parameters for statistical model checking can be changed in the Options menu. Various data plots (if available) can be accessed via popup-menu by right-clicking the statistical property. The y-axis always denotes a probability or its density, while x-axis denotes either the variable values limited by the statistical query or a step (transition) count in the model run.\n Probability density distribution A histogram created from probability distribution where each bucket is normalized by a bucket width. Useful for comparison of various distributions, potentially with different bucket widths. Probability distribution A histogram created from a frequency histogram where each bucket is normalized by a total number of runs. Useful for assessing a probability of a property being satisfied at a particular moment in time interval. Cumulative probability distribution A histogram created by adding up all frequency histogram buckets up to the current bucket and normalized by a total number of runs. Confidence Intervals for Probabilities The confidence intervals for probabilities are computed using Clopper-Pearson method (also known as \"exact\") for binomial distribution for a given level of confidence (1-α). The method is conservative in a sense that it guarantees the minimum coverage of the real probability in (1-α) of cases. In the plots, the estimated confidence is valid only for one bucket at a time (the gathered data is reused to compute each individual bucket). Confidence Intervals for Mean The confidence intervals for mean estimation are computed using quantiles of Student's t-distribution for a given level of confidence of 1-α. Note that t-distribution approaches the commonly used Normal (Gaussian) distribution when the number of samples is high. Frequency histogram The frequency histogram is created by calculating the number of runs satisfying the property at a particular moment in time interval. Useful for calculating the number of runs.  Any plot can be customized from a popup menu by right-clicking on the plot.\nFurther, the plot labels and titles can be edited and several data sets can be superimposed in one figure by using Plot Composer, accessible from the Tools menu. It is possible to create several composite plots at a time by invoking Plot Composer multiple times.\nAn extensive overview and comparison of methods for computing confidence intervals for binomial distribution can be found in the following publications:\n Interval Estimators for a Binomial Proportion: Comparison of Twenty Methods, Ana M. Pires and Conceicao Amado. REVSTAT \u0026ndash; Statistical Journal, Vol.6, No.2, June 2008, pages 165-197.\n  Interval Estimation for a Binomial Proportion, Lawrence D. Brown, T. Tony Cai and Anirban DasGupta. Statistical Science, 2001, Vol.16, No.2, pages 101-133.\n "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/toolsandapi/verifyta/","title":"verifyta","tags":[],"description":"","content":"The verifier functionality is accessible through verifyta command line utility in bin-Windows or bin-Linux directory of the distribution. The supported options are displayed when running verifyta -h.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/system-editor/declarations/","title":"Declarations","tags":[],"description":"","content":"Types, constants, variables and functions can be defined in the global scope by placing them in the global section labelled Declarations or System declarations, or locally for a template by placing in the Declarations section of a template.\nProcesses are instantiated by placing a process assignments in the System declarations section.\nFinally, the system is defined as a parallel composition of a number of processes by placing a system declaration in the System declarations section.\nThe syntax for each of these sections is defined in the Language Reference.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/expressions/","title":"Expressions","tags":[],"description":"","content":"Most of the expression syntax of UPPAAL coincides with that of C, C++ and Java. E.g. assignments are done using the \u0026lsquo;=\u0026rsquo; operator (the older \u0026lsquo;:=\u0026rsquo; still works, but \u0026lsquo;=\u0026rsquo; is preferred). Notice that assignments are them self expressions.\nThe syntax of expressions is defined by the grammar for Expression.\nExpression ::= [ID] | NAT | Expression \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; | Expression \u0026#39;\u0026#39;\u0026#39; | \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; | Expression \u0026#39;++\u0026#39; | \u0026#39;++\u0026#39; Expression | Expression \u0026#39;--\u0026#39; | \u0026#39;--\u0026#39; Expression | Expression Assign Expression | Unary Expression | Expression Binary Expression | Expression \u0026#39;?\u0026#39; Expression \u0026#39;:\u0026#39; Expression | Expression \u0026#39;.\u0026#39; ID | Expression \u0026#39;(\u0026#39; Arguments \u0026#39;)\u0026#39; | \u0026#39;forall\u0026#39; \u0026#39;(\u0026#39; ID \u0026#39;:\u0026#39; Type \u0026#39;)\u0026#39; Expression | \u0026#39;exists\u0026#39; \u0026#39;(\u0026#39; ID \u0026#39;:\u0026#39; Type \u0026#39;)\u0026#39; Expression | \u0026#39;sum\u0026#39; \u0026#39;(\u0026#39; ID \u0026#39;:\u0026#39; Type \u0026#39;)\u0026#39; Expression | \u0026#39;deadlock\u0026#39; | \u0026#39;true\u0026#39; | \u0026#39;false\u0026#39; Arguments ::= [ Expression ( \u0026#39;,\u0026#39; Expression )* ] Assign ::= \u0026#39;=\u0026#39; | \u0026#39;:=\u0026#39; | \u0026#39;+=\u0026#39; | \u0026#39;-=\u0026#39; | \u0026#39;*=\u0026#39; | \u0026#39;/=\u0026#39; | \u0026#39;%=\u0026#39; | \u0026#39;|=\u0026#39; | \u0026#39;\u0026amp;=\u0026#39; | \u0026#39;^=\u0026#39; | \u0026#39;\u0026lt;\u0026lt;=\u0026#39; | \u0026#39;\u0026gt;\u0026gt;=\u0026#39; Unary ::= \u0026#39;+\u0026#39; | \u0026#39;-\u0026#39; | \u0026#39;!\u0026#39; | \u0026#39;not\u0026#39; Binary ::= \u0026#39;\u0026lt;\u0026#39; | \u0026#39;\u0026lt;=\u0026#39; | \u0026#39;==\u0026#39; | \u0026#39;!=\u0026#39; | \u0026#39;\u0026gt;=\u0026#39; | \u0026#39;\u0026gt;\u0026#39; | \u0026#39;+\u0026#39; | \u0026#39;-\u0026#39; | \u0026#39;*\u0026#39; | \u0026#39;/\u0026#39; | \u0026#39;%\u0026#39; | \u0026#39;\u0026amp;\u0026#39; | \u0026#39;|\u0026#39; | \u0026#39;^\u0026#39; | \u0026#39;\u0026lt;\u0026lt;\u0026#39; | \u0026#39;\u0026gt;\u0026gt;\u0026#39; | \u0026#39;\u0026amp;\u0026amp;\u0026#39; | \u0026#39;||\u0026#39; | \u0026#39;\u0026lt;?\u0026#39; | \u0026#39;\u0026gt;?\u0026#39; | \u0026#39;or\u0026#39; | \u0026#39;and\u0026#39; | \u0026#39;imply\u0026#39; Like in C++, assignment, preincrement and predecrement expressions evaluate to references to the first operand. The inline-if operator does in some cases (e.g. when both the true and false operands evaluate to compatible references) also evaluate to a reference, i.e., it is possible to use an inline-if on the left hand side of an assignment.\nThe use of the deadlock keyword is restricted to the requirement specification language.\nBoolean Values Boolean values are type compatible with integers. An integer value of 0 (zero) is evaluated to false and any other integer value is evaluated to true. The boolean value true evaluates to the integer value 1 and the boolean value false evaluates to the integer value 0. Notice: A comparison like 5 == true evaluates to false, since true evaluates to the integer value 1. This is consistent with C++.\nPrecedence UPPAAL operators have the following associativity and precedence, listed from the highest to lowest. Operators borrowed from C keep the same precedence relationship with each other.\n   left () [] .   right ! not ++ -- unary -   left * / %   left - +   left    left ?   left =    left == !=   left \u0026   left ^   left |   left \u0026\u0026 and   left || or imply   right ?:   right = := += -= *= /= %= \u0026= |= = ^=   left forall exists sum    Operators Anybody familiar with the operators in C, C++, Java or Perl should immediately feel comfortable with the operators in UPPAAL. Here we summarise the meaning of each operator.\n   () Parenthesis alter the evaluation order   [] Array lookup   . Infix lookup operator to access process or structure type scope   ! Logical negation   ++ Increment (can be used as both prefix and postfix operator)   -- Decrement (can be used as both prefix and -- --postfix operator)   - Integer subtraction (can also be used as unary negation)   + Integer addition   * Integer multiplication   / Integer division   % Modulo    Left bitshift    Right bitshift    Minimum   ? Maximum    Less than    Less than or equal to   == Equality operator   != Inequality operator   = Greater than or equal to    Greater than   \u0026 Bitwise and   ^ Bitwise xor   | Bitwise or   \u0026\u0026 Logical and   || Logical or   ?: If-then-else operator   not Logical negation   and Logical and   or Logical or   imply Logical implication   forall Forall quantifier   exists Exists quantifier   sum Sum expression    Notice that the keywords not, and and or behave the same as the !, \u0026amp;\u0026amp;, and || operators, except that the former have lower precedence.\nA few binary operators can be syntactically combined with assignment to produce a compact assignment expression:\n   Operator Assignment Example Meaning   + += x += y x = x + y   - -= x -= y x = x - y   * *= x *= y x = x * y   / /= x /= y x = x / y   % %= x %= y x = x % y   \u0026 \u0026= x \u0026= y x = x \u0026 y   ^ ^= x ^= y x = x ^ y   | |= x |= y x = x | y     x x = x    = x = y x = x  y    Expressions Involving Clocks When involving clocks, the actual expression syntax is restricted by the type checker. Expressions involving clocks are divided into three categories: Invariants, guards, and constraints:\n An invariant is a conjunction of upper bounds on clocks and differences between clocks, where the bound is given by an integer expression, and clock rates. A guard is a conjunction of bounds (both upper and lower) on clocks and differences between clocks, where the bound is given by an integer expression. A constraint is any boolean combination (involving negation, conjunction, disjunction and implication) of bounds on clocks and differences between clocks, where the bound is given by an integer expression.  In addition, any of the three expressions can contain expressions (including disjunctions) over integers, as long as invariants and guards are still conjunctions at the top-level. The full constraint language is only allowed in the requirement specification language.\nOut of Range Errors and Invalid Evaluations An evaluation of an expression is invalid if out of range errors occur during evalution. This happens in the following situations:\n Division by zero. Shift operation with negative count. Out of range assignment. Out of range array index. Assignment of a negative value to a clock. Function calls with out of range arguments. Function calls with out of range return values.  In case an invalid evaluation occurs during the computation of a successor, i.e., in the evaluation of a guard, synchronisation, assignment, or invariant, then the verification is aborted.\nQuantifiers An expression forall (ID : Type) Expr evaluates to true if Expr evaluates to true for all values ID of the type Type. An expression exists (ID : Type) Expr evaluates to true if Expr evaluates to true for some value ID of the type Type. In both cases, the scope of ID is the inner expression Expr, and Type must be a bounded integer or a scalar set.\nExample The following function can be used to check if all elements of the boolean array a have the value true.\nbool alltrue(bool a[5]) { return forall (i : int[0,4]) a[i]; } Sum An expression sum (ID : Type) Expr evaluates to an integer and is equal to the sum of the expressions evaluated with ID ranging over the given type argument. Boolean or state predicates (in TCTL expressions only) are accepted but not clock constraints. The expressions must be side-effect free. The type must be a bounded integer or a scalar set.\nFloating Point Type Support Statistical model checking (SMC) supports double precision floating point type double. The clock variables also have floating point values in SMC. Symbolic and statistical model checking can be applied on the same model provided that double and hybrid clock type variables do not influencing the model logic, i.e. they cannot be used in guard and invariant constraints (but can be used in ODE expressions).\nThe following is the list of builtin floating point functions (mostly imported from C math library, hence the C math manual can be consulted for more details):\n int abs(int) — absolute value of integer argument. double fabs(double) — absolute value of double argument. double fmod(double x, double y) — remainder of the division opration x/y. double fma(double x, double y, double z) — computes x*y+z as if to infinite precision. double fmax(double x, double y) — the larger of the two arguments. double fmin(double x, double y) — the smaller of the two arguments. double exp(double x) — Euler\u0026rsquo;s number raised to the given power: ex. double exp2(double x) — 2 raised to the given power: 2x. double expm1(double x) — Euler\u0026rsquo;s number raised to the given power minus 1: ex-1. double ln(double x) — logarithm to the base of Euler\u0026rsquo;s number: loge(x). double log(double x) — logarithm to the base of 10 log10(x) (this is different from C library, kept for backward compatibility reasons). double log10(double x) — logarithm to the base of 10: log10(x). double log2(double x) — logarithm to the base of 2: log2(x). double log1p(double x) — logarithm to the base of Euler\u0026rsquo;s number with argument plus 1 loge(1+x). double pow(double x, int y) — raises to the specified integer power xy. double pow(double x, double y) — raises to the specified floating point power xy. double sqrt(double x) — computes square root. double cbrt(double x) — computes cubic root. double hypot(double x, double x) — computes hypotenuse of a right triangle: sqrt(x2+y2). double sin(double x) — sine of an angle in radians. double cos(double x) — cosine of an angle in radians. double tan(double x) — tangent of an angle in radians. double asin(double x) — arc sine in radians. double acos(double x) — arc cosine in radians. double atan(double x) — arc tangent in radians. double atan2(double y, double x) — arc tangent of the ratio y/x in radians. double sinh(double x) — hyperbolic sine: (exp(x)-exp(-x))/2. double cosh(double x) — hyperbolic cosine: (exp(x)+exp(-x))/2. double tanh(double x) — hyperbolic tangent: (exp(x)-exp(-x))/(exp(x)+exp(-x)). double asinh(double x) — inverse hyperbolic sine. double acosh(double x) — inverse hyperbolic cosine. double atanh(double x) — inverse hyperbolic tangent. double erf(double x) — Gauss error function (special non-elementary function of sigmoid). double erfc(double x) — complement of a Gauss error function. double tgamma(double x) — absolute value of the Gamma function (an extension of a factorial function Γ(n)=(n-1)!). double lgamma(double x) — natural logarithm of the Gamma function. double ceil(double x) — the ceiling function, the smallest integer value not less than x. double floor(double x) — the floor function, the largest integer value not greater than x. double trunc(double x) — nearest integer not greater in magnitude than x. double round(double x) — nearest integer value to x rounding halfway cases away from zero. int fint(double x) — converts floating point value into integer (works like trunc()). double ldexp(double x, int y) — multiplies by a specified power of two: x*2y. int ilogb(double x) — extracts unbiased exponent: trunc(log2(x+1)). double logb(double x) — extracts unbiased exponent: trunc(log2(x+1)). double nextafter(double from, double to) — a next representable floating point value of from in the direction of to. double copysign(double x, double y) — floating point value with magnitude of x and sign of y. bool signbit(double x) — true if the argument x is negative.\u0026lt; double random(double max) — pseudo random number distributed uniformly over the interval [0,max). double normal(double mean, double stddev) — pseudo random number distributed according to normal (Gaussian) distribution for a given mean and standard deviation stddev.  A few common constants and types can be declared as follows:\nconst int INT16_MIN = -32768; const int INT16_MAX = 32767; const int UINT16_MAX = 65535; const int INT32_MIN = -2147483648; const int INT32_MAX = 2147483647; const int UINT32_MAX = 4294967295; typedef int[INT32_MIN, INT32_MAX] int32_t; typedef int[0, UINT32_MAX] uint32_t; const double M_PI = 3.14159265358979312; // Pi const double M_PI_2 = 1.57079632679489656; // Pi/2 const double M_PI_4 = 0.785398163397448279; // Pi/4 const double M_E = 2.71828182845904509; // Euler\u0026#39;s number e const double M_LOG2E = 1.44269504088896339; // log_2(e) const double M_LOG10E = 0.434294481903251817; // log_10(e) const double M_LN2 = 0.693147180559945286; // log_e(2) const double M_LN10 = 2.3025850929940459; // log_e(10) const double M_1_PI = 0.318309886183790691; // 1/Pi const double M_2_PI = 0.636619772367581382; // 2/Pi const double M_2_SQRTPI = 1.12837916709551256; // 2/sqrt(Pi) const double M_SQRT2 = 1.41421356237309515; // sqrt(2) const double M_SQRT1_2 = 0.707106781186547573; // 1/sqrt(2) "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/system-definition/gantt-chart/","title":"Gantt Chart","tags":[],"description":"","content":"A Gantt chart, commonly used in project management, is a bar chart that shows activities displayed against time. On the left of the chart is a list of the activities and along the top is a suitable time scale. Each activity is represented by a bar; the position and length of the bar reflect the start date, duration and end date of the activity.\nIn UPPAAL Gantt Charts are used to automatic visualize traces. One needs to specify the list of activities and for each activity, what the different colored parts of the bar should reflect.\nThe Gantt Chart specification is placed after the system definition. The syntax is defined by the following grammar:\nGanttDecl ::= \u0026#39;gantt {\u0026#39; GanttDef \u0026#39;}\u0026#39; GanttDef ::= \u0026#39;\u0026#39; | GanttDef NonTypeId GanttArgs \u0026#39;:\u0026#39; GanttExprList \u0026#39;;\u0026#39; GanttArgs ::= \u0026#39;\u0026#39; | \u0026#39;(\u0026#39; GanttDeclSelect \u0026#39;)\u0026#39; GanttDeclSelect ::= [Id] \u0026#39;:\u0026#39; [Type] | GanttDeclSelect \u0026#39;,\u0026#39; Id \u0026#39;:\u0026#39; Type GanttExprList ::= GanttExpr | GanttExprList \u0026#39;,\u0026#39; GanttExpr GanttExpr ::= [Expression] \u0026#39;-\u0026gt;\u0026#39; [Expression] | \u0026#39;for (\u0026#39; GanttEntrySelect \u0026#39;)\u0026#39; [Expression] \u0026#39;-\u0026gt;\u0026#39; [Expression] GanttEntrySelect ::= Id \u0026#39;:\u0026#39; Type | GanttEntrySelect \u0026#39;,\u0026#39; Id \u0026#39;:\u0026#39; Type The first part of GanttDef (the one before the colon) specifies the list of activities. The second part (the one after the colon) specifies for each activity, what the bar should reflect.\nAn instance of GanttExpr consists of two expressions. The one before -\u0026gt; is evaluated to a boolean value. If it is evaluated to true, the expression after -\u0026gt; will be evaluated to an integer. Note that this integer is not necessarily a constant. The integer will be map to a color (e.g. 0 will be map to red and 1 to green), which is the color of the bar when the expression is evaluated to true.\nGanttDeclSelect and for (\u0026hellip;) are to be considered as syntax shortcuts rather than constructs.\nExamples Sample color definitions:\nconst int C_RED = 0; const int C_GREEN = 1; const int C_BLUE = 2; const int C_PURPLE = 3; const int C_ORANGE = 5; const int C_YELLOW = 6; const int C_CYAN = 9; gantt { Red: true -\u0026gt; C_RED; Colors(i:int[0,32]): true -\u0026gt; i; } Scheduling gantt { Task(i : pid_t): Task(i).Ready -\u0026gt; 1, Task(i).Running -\u0026gt; 2, Task(i).Blocked -\u0026gt; 3, Task(i).Error -\u0026gt; 0, for(j : sid_t) Task(i).sema[j] -\u0026gt; 6; Scheduler: len==0 -\u0026gt; 0, len\u0026gt;0 -\u0026gt; 1; } Train Gate gantt { Xxxx: Train(0).Cross -\u0026gt; 0, Train(1).Cross -\u0026gt; 1, Train(2).Cross -\u0026gt; 2; Gate: true -\u0026gt; Gate.len; } "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/toolsandapi/javaapi/","title":"Java API","tags":[],"description":"","content":"UPPAAL models can be created, loaded, saved, simulated and checked using libs/model.jar library. A demonstrating example is included in the demo/ModelDemo.java file.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/parameters/","title":"Parameters","tags":[],"description":"","content":"Templates and functions are parameterised. The syntax for parameters is defined by the grammar for Parameters:\nParameters ::= [ Parameter (\u0026#39;,\u0026#39; Parameter)* ] Parameter ::= [Type] [ \u0026#39;\u0026amp;\u0026#39; ] [ID] [ArrayDecl]* In contrast to global and local declarations, the parameter list should not be terminated by a semicolon.\nCall by Reference and Call by Value Parameters can be declared to have either call-by-value or call-by-reference semantics. The syntax is taken from C++, where the identifier of a call-by-reference parameter is prefixed with an ampersand in the parameter declaration. Call-by-value parameters are not prefixed with an ampersand.\nClocks and channels must always be reference parameters.\nNote: Array parameters must be prefixed with an ampersand to be passed by reference, this does not follow the C semantics.\nExamples  P(clock \u0026amp;x, bool bit)\nprocess template P has two parameters: the clock x and the boolean variable bit. Q(clock \u0026amp;x, clock \u0026amp;y, int i1, int \u0026amp;i2, chan \u0026amp;a, chan \u0026amp;b)\nprocess template Q has six parameters: two clocks, two integer variables (with default range), and two channels. All parameters except i1 are reference parameters.  "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/concrete-simulator/process/","title":"Process Panel","tags":[],"description":"","content":"The process panel is the rightmost upper panel of the simulator. It displays the process instances of the system descriptions. A red token marks the current control point of each automaton. One or more of the automata edges may also be red to indicate the transition currently selected in the simulation control panel.\nClicking inside a process box with the right mouse button opens a pop-up menu with the following items:\n Zoom In: increases the zoom of the process, Zoom Out: decreases the zoom of the process, Hide: hides the process, Export: opens a file dialog for saving the process in encapsulated postscript format.  "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/symbolic-simulator/simulation-control/","title":"Simulation Control","tags":[],"description":"","content":"The simulation control is the left panel of the simulator. It is used to control the simulation and to select the (symbolic) state or transition to be visualized in the other two panels of the simulator. The control panel is divided in two parts:\nThe upper part is used for performing step-by-step simulation. A list view displays the enabled transitions, with the currently selected transition highlighted. Pressing the Next-button causes the simulated system to take the selected transition. The Reset-button is used to reset the simulated system to its initial state.\nThe lower part of the control panel has a view displaying the generated trace. The displayed trace is an alternating sequence of control location vectors and transitions. The simulation always progresses from the highlighted element in this view. It is possible to change the selection using the mouse.\nThe six buttons below the trace view have the following semantics:\n Prev: highlights the element immediately preceding the current selection (if any) in the trace. Next: highlights the element immediately following the current selection (if any) in the trace. Replay: replays the trace starting from the currently selected element. Open: opens a file dialog for loading a trace from file. Save: opens a file dialog for saving the current trace on file. Random: starts a random simulation where the simulator proceed automatically by randomly selecting enabled transitions.  The slider at the bottom of the control panel is used to control the speed used when traces are replayed and when random simulation is performed.\nKeyboard Shortcuts    Key Shortcut to   Z Move selection up in the enabled transitions list view.   X Move selection down in the enabled transitions list view.   Q Correspond to the button Prev.   A Correspond to the button Next.   P Correspond to the button Replay.   R Correspond to the button Random.   F Highlights the first element in the trace.   L Highlights the last element in the trace.    Toggle selection of an enabled transition.    Follow the selected enabled transition.    "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/system-editor/","title":"System Editor","tags":[],"description":"","content":"The system editor is used to create and edit the system to be analysed. A system description is defined by a set of process templates (possibly with local declarations), global declarations, and a system definition.\nIn this help section we describe how to use the left panel of the editor, called the navigation tree, how to draw automata with the editor, and where to place declarations. The system description language used in UPPAAL is described in the Language Reference section.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/toolsandapi/","title":"Tools &amp; API","tags":[],"description":"","content":"Chapter 1 Tools \u0026amp; API "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/symbolic-simulator/variables/","title":"Variables Panel","tags":[],"description":"","content":"The variables panel is the middle panel of the simulator. It displays the values of the data and clock variables in the current state or transition selected in the trace of the simulation control panel.\nThe data variable values are always shown as integers. The clock values are shown symbolically as a conjunction of clock guards of lower and upper bounds on individual clocks or differences between pairs of clocks (see Expressions section for more information on clock guards). The possible clock values of the associated state (or transition) are all possible solutions to the conjunction of all clock constraints. The symbols \u0026ldquo;[\u0026rdquo; and \u0026ldquo;]\u0026rdquo; are used for closed intervals and \u0026ldquo;(\u0026rdquo; and \u0026ldquo;)\u0026rdquo; for open intervals in the usual way.\nIf the selected element in the simulation control panel is a state, the variables panel shows the symbolic values of the state (in normal black color). If the selected element is a transition, the shown symbolic values are those of the immediately preceding state satisfying the guard(s) of the transition (shown in blue color).\nNote: variables can be hidden and displayed using the \u0026ldquo;Variables\u0026hellip;\u0026rdquo; item in the View menu. The representation of the clock constraints can also be changed from this menu, using the \u0026ldquo;Full DBM\u0026rdquo; item. When \u0026ldquo;Full DBM\u0026rdquo; is checked a constraint is shown for each pair of clocks, otherwise a minimum set of constraints is shown. The minimum set of constraints is such that all constraints that are in the full DBM but not in the minimum set can be derived from constraints in the minimum set.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/menu-bar/view/","title":"View Menu","tags":[],"description":"","content":"The view menu is used to modify the appearance of the system currently shown in the system editor and the simulator. The items are:\n  Zoom: shows a sub menu with fixed zoom values, zoom to fit, and itemes for zooming in, out, or to normal size. A change in the zoom value affects the templates the editor or the processes in the simulator (if one of the tools is active).\n  Labels: shows a sub menu from which one can select which type of labels should be shown in the drawing area. Even when hidden, all labels can be seen in the tooltip of locations and edges.\n  Show Grid: the drawing grid is shown when this item is checked.\n  Snap to Grid: makes new drawing objects (such as locations, nails, and labels) align to the snap grid. The size of the snap grid is related to the size of the drawing grid.\nNote: the Snap to Grid option can be used even if the drawing grid is not shown.\n  Coarser: increases the distance between the lines in the drawing grid.\n  Tighter: decreases the distance between the lines in the drawing grid.\n  Mark Visited highlights the locations and edges traversed by a trace in the simulator process panel.\n  Show Coverage shows graphs of location and edge coverage dynamics over the simulated trace in a popup window. The Mark Visited option above enables this menu item.\n  Reload Simulator: uploads the system currently loaded in the editor, to the simulator and the verifier.\n  Processes: displays a dialog window for hiding and showing processes in the process panel of the simulator.\n  Variables: shows a dialog window for hiding and showing variables in the variables panel of the simulator.\n  Full DBM: shows all constraints on the clocks in the variables panel of the simulator. If not selected a minimal number of constraints will be shown.\n  "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/concrete-simulator/sequence-chart/","title":"Message Sequence Chart","tags":[],"description":"","content":"The Message Sequence Chart (MSC) panel is the lower rightmost panel of the simulator. It displays an MSC view of the generated trace (also displayed in the simulation control panel of the simulator).\nIn the MSC view there is a vertical line for each process, and a horizontal line for each synchronisation point. The process name of each vertical line is indicated in the upper part of the MSC panel. The node names shown on the vertical lines indicate the control location of the automaton. If the mouse is placed over the MSC all control location names at the position are shown. If a position is selected, the process panel and the simulation control panel are updated accordingly.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/symbolic-simulator/process/","title":"Process Panel","tags":[],"description":"","content":"The process panel is the rightmost upper panel of the simulator. It displays the process instances of the system descriptions. A red token marks the current control point of each automaton. One or more of the automata edges may also be red to indicate the transition currently selected in the simulation control panel.\nClicking inside a process box with the right mouse button opens a pop-up menu with the following items:\n Zoom In: increases the zoom of the process, Zoom Out: decreases the zoom of the process, Hide: hides the process, Export: opens a file dialog for saving the process in encapsulated postscript format.  Note: several items in the View menu affect the processes in the process panel. For example, the \u0026ldquo;Processes\u0026hellip;\u0026rdquo; item may be used to hide and show processes.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/reserved-keywords/","title":"Reserved Keywords","tags":[],"description":"","content":"The reserved keywords that should not be used as identifier names when defining systems are: chan, clock, double, bool, int, commit, const, urgent, broadcast, init, process, state, invariant, location, guard, sync, assign, system, trans, deadlock, and, or, not, imply, true, false, for, forall, exists, while, do, if, else, return, typedef, struct, rate, before_update, after_update, meta, priority, progress, scalar, select, void, default, string.\nThe following keywords are reserved for future use: switch, case, continue, break, enum.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/toolsandapi/socketserver/","title":"Socketserver","tags":[],"description":"","content":"To start a remote server, use the socketserver binary (included for Linux, SunOS and MacOS). To use a remote server, see the section on command line options for the GUI.\nThe socketserver can be executed from the command line using one of the following commands:\n socketserver [-p] [-s]\nsocketserver -h\n The available command line options are:\n -h Prints a brief description of the command line options. -p Set port in server mode (default is 2350). -s Set filename of server binary to P2.  The socketserver will load the server from the directory where it was invoked, and act as a proxy.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/symbolic-simulator/","title":"Symbolic Simulator","tags":[],"description":"","content":"The simulator is a validation tool that enables examination of the possible dynamic executions of a system during early design (or modeling) stages. In this sense, it provides an inexpensive mean of fault detection prior to verification by the model-checker. The simulator is also used to visualise executions (i.e. symbolic traces) generated by the verifier. Please see the Symbolic Traces section for a brief introduction of the concept.\nThe simulator consist of four panels: the leftmost called simulation control, the middle called variables, the upper right called processes, and the lower right called message sequence chart.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/system-definition/","title":"System Definition","tags":[],"description":"","content":"In the system definition, a system model is defined. Such a model consists of one or more concurrent processes, local and global variables, and channels.\nGlobal variables, channels and functions can be defined in the system definition using the grammar for declarations. Such declarations have a global scope. However, they are not directly accessible by any template, as they are declared after the templates. They are most useful when giving actual arguments to the formal parameters of templates. The declarations in the system definition and in the top-level declarations section are part of the system model.\nThe processes of the system model are defined in the form of a system declaration line, using the grammar for System given below. The system line contains a list of templates to be instantiated into processes. Processes can be prioritised as described in the section on priorities.\nSystem ::= \u0026#39;system\u0026#39; ID ((\u0026#39;,\u0026#39; | \u0026#39;\u0026lt;\u0026#39;) ID)* \u0026#39;;\u0026#39; Templates without parameters are instantiated into exactly one process with the same name as the template. Parameterised templates give rise to one process per combination of arguments, i.e., UPPAAL automatically binds any free template parameters. Any such parameter must be either a call-by-value bounded integer and or a call-by-value scalar. Individual processes can be referenced in expressions using the grammar for Process given below. Notice that this is already covered by the grammar for expressions.\nProcess ::= ID \u0026#39;(\u0026#39; [Arguments] \u0026#39;)\u0026#39; It is often desirable to manually bind some or all formal parameters of a template to actual arguments. This can be done by partial instantiation of templates.\nAny progress measures for the model or Gantt chart are defined after the system line.\nExample In this example we use the textual syntax for template declaration as used in the XTA format. In the GUI, these templates would be defined graphically.\nprocess P() { state s...; ... } process Q(int[0,3] a) { state t...; ... } system P, Q; This defines a system consisting of five processes named P, Q(0), Q(1), Q(2) and Q(3). Automatic binding of template parameters is very useful in models in which a large number of almost identical processes must be defined, e.g., the nodes of a network in a model of a communication protocol. In order to express that, e.g., all Q processes must be in location s, an expression like forall (i : int[0,3]) Q(i).s suffices.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/menu-bar/tools/","title":"Tools Menu","tags":[],"description":"","content":"The tools menu contains a set of tools useful in the system edtior. The items are:\n Check Syntax: checks if syntax and types are correct in the edited system. Any found errors and warnings are listed in the lower part of the drawing area of the system editor, and (when applicable) underlinded in the automata. Convert Syntax: assists in convering a system complying with the syntax used in UPPAAL 3.4 to the current syntax. Align to Grid: makes all existing objects of the current template align to the specified drawing grid. Plot Composer: creates a new Plot Composer window to superimpose multiple results from statistical model checking in the Verifier.  "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/concrete-simulator/","title":"Concrete Simulator","tags":[],"description":"","content":"The concrete simulator is similar to the symbolic simulation in the sense that it is a validation tool that enables examination of the possible dynamic executions of a system during early design (or modeling) stages. The difference is that the simulation is based on concrete traces, i.e. one can choose a specific time to fire a transition. The tool helps to see at which time a transition can be fired.\nThe concrete simulator consists of the following panels:\n Simulation Control   Variables Panel   Process Panel   Message Sequence Chart   Gantt Chart Panel   "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/toolsandapi/file-formats/","title":"File Formats","tags":[],"description":"","content":"UPPAAL supports three file formats for models: XML, XTA and TA. XML and XTA files can be loaded and stored via the Open Project, Open System, Save System, and Save System As menus. When saving a file, the file type is determined by the file name extension used. Each format is explained in more details below.\nNotice that the above mentioned file formats are mostly independent from the type of changes made to the syntax between UPPAAL 3.4 and UPPAAL 4.0.\nIn additon to the file formats for models, UPPAAL uses clear text query files for storing queries and the XTR file format for storing traces.\nXML The newest format is XML based and files in this format have the ending .xml. This format supports all features of UPPAAL. Elements like templates, locations, edges and labels are described using tags. This format was introduced in the GUI in version 3.2. As of version 3.4, the XML format is also supported by the verification engine. The GUI uses this format as its native file format. The addition of colors and notes on labels and edges, and the select expresssion on edges in UPPAAL 4.0 has resulted in the addition of a color attribute and two new label types. If these features are not used, the XML files generated by UPPAAL 4.0 are readable by UPPAAL 3.4.\nThe level of abstraction in the format is chosen so that the format is independent of the actual syntax of declarations, invariants, guards, etc. Thus all labels are simply treated as strings without structure. In a GUI, this is very important, since the user might enter arbitrary text into the label fields and the file format must be able to cope with this situation. Before the introduction of the XML format, the XTA format was used. With this format it was not possible to save syntactically incorrect systems, i.e., if the user made a mistake in the syntax of a label it was not possible to save this systems.\nXTA The XTA format was introduced in version 3.0. This format can only reliably store syntactically correct systems. Anonymous locations are not supported by this format (UPPAAL automatically assigns a unique name to anonymous locations when saved to an XTA file). Graphical information (coordinates) about the objects are stored in a separate UGI file, although this is transparent to the user. XTA files use the ending .xta and UGI files the ending .ugi.\nIn UPPAAL 4.0, the XTA format was extended with support for the select expression on edges. The UGI format was extended with support for the color attributes. If these features are not used, the XTA files generated by UPPAAL 4.0 are readable by UPPAAL 3.4.\nTA The TA format is a subset of the XTA format and does not support the template concept nor does it contain any graphical information about the system. UPPAAL can no longer save files in this format, although TA files can still be read.\nQuery files Query files use a clear-text format listing all queries inleaved with comments. The format dates back to UPPAAL 2. Files in this format have the file ending .q.\nTrace files Traces can be stored using the XTR format and files in this format have the file ending .xtr. The format was introduced in UPPAAL 3.0.\nXTR files are intimately linked to the model from which they were generated. Any change (other than layout and white space changes) in the model may render the trace file unreadable. Even reordering some variable declarations will break the link.\nOur parser library, libutap, contains a small utility called tracer, which can read XTR files and translate them to a human readable format. The library and the utility are released under the LGPL license and may thus be used as a starting point for writing custom trace analysis tools. More information about the library can be found on the UPPAAL web page.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/concrete-simulator/gantt-chart/","title":"Gantt Chart Panel","tags":[],"description":"","content":"The Gantt Chart panel is the middle rightmost panel of the simulator. It displays another view of the generated trace according to the Gantt Chart specification given in system definition.\nIn the Gantt Chart view, the horizontal axis represents the time span, and in the vertical axis the list of activities (usually some of the system processes) defined in the Gantt chart specification are listed. A vertical line is used to represent the current time (which corresponds to the one displayed in the Simulation Trace-combo box). Horizontal bars of varying lengths and colors represent when the different expressions in the Gantt chart specification are satisfied according to the current state of the trace.\nIf the mouse is placed over a Gantt bar, information about the intervals when the corresponding expressions are satisfied are shown.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/symbolic-simulator/sequence-charts/","title":"Message Sequence Chart","tags":[],"description":"","content":"The Message Sequence Chart (MSC) panel is the lower rightmost panel of the simulator. It displays an MSC view of the generated trace (also displayed in the simulation control panel of the simulator).\nIn the MSC view there is a vertical line for each process, and a horizontal line for each synchronisation point. The process name of each vertical line is indicated in the upper part of the MSC panel. The node names shown on the vertical lines indicate the control location of the automaton. If the mouse is placed over the MSC all control location names at the position are shown. If a position is selected, the process panel and the simulation control panel are updated accordingly.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/menu-bar/options/","title":"Options Menu","tags":[],"description":"","content":"The options menu contains settings to control the behavior of the model-checker.\nSearch Order This option influences the order in which the state space is explored.\n Breadth first Search the state space in breadth first search order. This is typically the most efficient option when the complete state space must be searched. When generating shortest or fastest traces, this is likely the best setting. Depth first Search the state space in depth first search order. If a counter example or witnessing trace is expected to exist, this setting is usually better than the breadth first setting. It is not recommended to use this search order when generating shortest or fastest traces. Random depth first Search the state space in randomised depth first search order. If a counter example or witnessing trace is expected to exist, this is usually the best setting. Due to the randomisation, traces may vary from run to run. It is not recommended to use this search order when generating shortest or fastest traces.  State Space Reduction When searching the state space, UPPAAL does not necessarily have to store all states in memory in order to guarantee termination. This option influences how aggressively UPPAAL tries to avoid storing states. There is normally a tradeoff between space and speed.\n None Store all states. Conservative Avoid storing committed states. Aggressive Avoid storing more than one state per cycle.  State Space Representation This option determines how the state space should be represented in the model checker.\nSome representations are approximative in the sence that either a larger or smaller state space than the real one is generated. When an approximative representation is used, UPPAAL may conclude that a query is maybe satisfied, i.e., UPPAAL cannot make a decisive conclusions given the representation selected.\n Difference Bound Matrices (DBM) DBMs are often fast, but for models with many clocks they require a lot of memory. Compact Data Structure A more compact, but slower representation than DBMs. In particular for models with many clocks, this setting will often significantly reduce memory consumption. Even for models with no or few clocks, this option enables other memory saving techniques at the expense of speed. Under Approximation Uses bit-state hashing to represent the state space. This results in an under approximation, however the degree of approximation can be adjusted by adjusting the size of the hash table: Large hash tables result in a larger part of the state space being searched. The hash table size can be selected with the _hash table size_ option. Over Approximation Uses convex-hull approximation of zones. This results in an over approximation of the state space. For models without clocks, this setting has no effect.  Diagnostic Trace This option controls if a counter-example or witnessing trace (if there is one) should be generated during verification. The trace is loaded into the simulator after verification. Enabling trace generation has two side effects:\n Only one property at a time can be verified. Symmetry reduction is disabled.  The possible settings for trace generation are:\n None Do not generated any diagnostic trace. Some Generate a diagnostic trace. Shortest Generate a shortest trace, i.e. a trace with the smallest number of transitions. Fastest Generate a fastest trace, i.e. a trace with the shortest accumulated time delay.  Extrapolation The range of clocks is unbounded, i.e., clocks can obtain arbitrarily large real values. To guarantee termination, UPPAAL uses an abstraction techniques called extrapolation. The extrapolated state space is finite. UPPAAL implements a number of extrapolation techniques that differ in the size of the extrapolated state space. Not all extrapolation techniques preserve all properties for all kinds of models. UPPAAL automatically selects the coarsets extrapolation, which still preserves the property being analysed.\nSometimes it may be of benefit to use a coarser (and faster) extrapolation that the one selected by UPPAAL. By doing so, the analysis will use an over-approximation of the state space. Listed from finest to coarsets, the choices are: None, Difference, Local, and Lower/Upper.\n Automatic Selects the coarsest extrapolation preserving the property being analysed. If in doubt, use this setting. None Do not use extrapolation. Termination is no longer guaranteed. Since performing the extrapolation is relatively expensive, this may be of use if you know that the symbolic state space is finite. Difference Used whenever the model or the query contain difference constraints over clocks, e.g., x - y . Local Used whenever the query contains either the deadlock keyword or involves a liveness property (except if the model or the query contain difference constraints). Lower/Upper Used whenever a reachability analysis is performed, except when the deadlock keyword is used or when the model or the query contain difference constraints.  Hash table size Adjusts the amount of memory used to represent the state space when using bit-state hashing. This option has no effect unless under approximation is selected.\nReuse When selected, instructs the verifier to (whenever possible) reuse the generated portion of the state space when several properties of the same system are checked.\nStatistical Parameters   Lower probabilistic deviation (-δ) Used in hypothesis testing (qualitative model-checking) to specify the lower bound of indifference region from the specified probability. Upper probabilistic deviation (+δ) Used in hypothesis testing (qualitative model-checking) to specify the upper bound of indifference region from the specified probability. Probability of false negatives (α) Used in hypothesis testing (qualitative model-checking) and probability estimation (quantitative model-checking) to specify the level of significance. Probability of false positives (β) Used in hypothesis testing (qualitative model-checking) to specify the level of significance. Probability uncertainty (ε) Used in probability estimation (qualitative model-checking) to constrain the probability interval. Ratio lower bound (u0) Used in comparison of two probabilities. Ratio upper bound (u1) Used in comparison of two probabilities. Histogram bucket width Specifies the width of each column in the histogram. By default it is set to zero meaning that the width is determined by ratio of entire histogram width divided by a bucket count. Histogram bucket count Specifies the number of columns in the histogram. By default it is set to zero meaning that the count is determined by taking a square root of a total number of samples and dividing by four.  More Information The compact data structure and the options for state space reduction are described in the following paper:\n Efficient Verification of Real-Time Systems: Compact Data Structure and State Space Reduction, Kim G. Larsen, Fredrik Larsson, Paul Pettersson and Wang Yi. In Proceedings of the 18th IEEE Real-Time Systems Symposium, pages 14-24. San Francisco, California, USA, 3-5 December 1997.\n "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/priorities/","title":"Priorities","tags":[],"description":"","content":"Given some priority order on the transitions, the intuition is that, at a given time-point, a transition is enabled only if no higher priority transition is enabled (see also Semantics.) We say that the higher priority transition blocks the lower priority transition.\nPriorities can be assigned to the channels and processes of a system. The priority orders defined in the system are translated into a priority order on tau-transitions and synchronizing transitions. Delay transitions are still non-deterministic (unless urgent channels are used.)\n Priorities on Channels Priorities on Processes Priorities on both Channels and Processes  Priorities on Channels ChanPriority ::= \u0026#39;chan\u0026#39; \u0026#39;priority\u0026#39; (ChanExpr | \u0026#39;default\u0026#39;) ((\u0026#39;,\u0026#39; | \u0026#39;\u0026lt;\u0026#39;) (ChanExpr | \u0026#39;default\u0026#39;))* \u0026#39;;\u0026#39; ChanExpr ::= ID | ChanExpr \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; A channel priority declaration can be inserted anywhere in the global declarations section of a system (only one per system). The priority declaration consist of a list of channels, where the \u0026lsquo;\u0026lt;\u0026rsquo; separator defines a higher priority level for channels listed on its right side. The default priority level is used for all channels that are not mentioned, including tau transitions.\nNote: the channels listed in the priority declaration must be declared earlier.\nExample chan a,b,c,d[2],e[2]; chan priority a,d[0] \u0026lt; default \u0026lt; b,e; The example assigns the lowest priority to channels a and d[0], and the highest priority to channels b, e[0] and e[1]. The default priority level is assigned to channels c and d[1].\nPriorities on Processes Process priorities are specified on the system line, using the separator \u0026lsquo;\u0026lt;\u0026rsquo; to define a higher priority for processes to its right. If an instance of a template set is listed, all processes in the set will have the same priority.\nExample system A \u0026lt; B,C \u0026lt; D; Resolving Synchronization In a synchronisation the process priorities are ambigous, because more than one process is involved in such a transition.\nWhen several processes synchronize, the priority of the transition is given by the highest priority of the processes. This applies to both standard synchronization and broadcast.\nPriorities on both Channels and Processes In a system with priorities on both processes and channels, priorities are resolved by comparing priorities on channels first. If they are the same, the process priorities are compared.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/menu-bar/help/","title":"Help Menu","tags":[],"description":"","content":"The help menu has two items: Help which opens a separate window showing the help pages, and About which opens a window showing the version number and information about the copyrights of UPPAAL.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/toolsandapi/latex/","title":"Latex","tags":[],"description":"","content":"UPPAAL web site includes links to uppaal.sty file — style for typesetting documents in LaTeX.\n UPPAAL Latex  "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/scope-rules/","title":"Scope Rules","tags":[],"description":"","content":"The scope rules determine which element a name refers to in a given context. The context is either local (to a process template), or global (in a system description).\nIn a local context, the names are always referring to local declarations or formal parameters (if the name is locally defined), otherwise to a globally declared name.\nIn the global context, a name is always referring to a global declaration.\nNote: There is only one name space in each context. This means that in each context all declared clocks, integer variables, constants, locations, and formal paramters must have unique names. However, local names may shadow globally declared names.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/language-reference/system-description/semantics/","title":"Semantics","tags":[],"description":"","content":"In the following we give a pseudo-formal semantics for UPPAAL. The semantics defines a timed transition system (S, s0, →) describing the behaviour of a network of extended timed automata. The set of states S is defined as {(L, v) | v ⊨ Inv(L)}, where L is a location vector, v is a function (called a valuation) mapping integer variables and clocks to their values, and Inv is a function mapping locations and location vectors to invariants. The initial state s0 is the state where all processes are in the initial location, all variables have their initial value, and all clocks are zero. The transition relation, →, contains two kinds of transitions: delay transitions and action transitions. We will describe each type below.\nGiven a valuation v and an expression e, we say that v satisfies e if e evaluates to non-zero for the given valuation v.\nInvalid Evaluations If during a successor computation any expression evaluation is invalid (consult the section on expressions for further details about invalid evaluations), the verification is aborted.\nDelay Transitions Delay transitions model the passing of time without changing the current location. We have a delay transition (L, v) −d→ (L, v'), where d is a non-negative real, if and only if:\n v' = v+d, where v+d is obtained by incrementing all clocks with d. for all 0 ≤ d' ≤ d: v+d' ⊨ Inv(L) L contains neither committed nor urgent locations for all locations ℓ in L and for all locations ℓ' (not necessarily in L), if there is an edge from ℓ to ℓ' then either:  this edge does not synchronise over an urgent channel, or this edge does synchronise over an urgent channel, but for all 0 ≤ d' ≤ d we have that v+d' does not satisfy the guard of the edge.    Action Transitions For action transtions, the synchronisation label of edges is important. Since UPPAAL supports arrays of channels, we have that the label contains an expression evaluating to a channel. The concrete channel depends on the current valuation. To avoid cluttering the semantics we make the simplifying assumption that each synchronisation label refers to a channel directly.\nPriorities increase the determinism of a system by letting a high priority action transition block a lower priority action transition. Note that delay transitions can never be blocked, and no action transition can be blocked by a delay transition.\nFor action transitions, there are three cases: Internal transitions, binary synchronisations and broadcast synchronisations. Each will be described in the following.\nInternal Transitions We have a transition (L, v) −*→ (L', v') if there is an edge e=(ℓ,ℓ') such that:\n there is no synchronisation label on e v satisfies the guard of e L' = L[ℓ'/ℓ] v' is obtained from v by executing the update label given on e v' satisfies Inv(L') Either ℓ is committed or no other location in L is committed. There is no action transition from (L, v) with a strictly higher priority.  Binary Synchronisations We have a transition (L, v) −*→ (L', v') if there are two edges e1=(ℓ1,ℓ1') and e2=(ℓ2,ℓ2') in two different processes such that:\n e1 has a synchronisation label c! and e2 has a synchronisation label c?, where c is a binary channel. v satisfies the guards of e1 and e2. L' = L[ℓ1'/ℓ1, ℓ2'/ℓ2] v' is obtained from v by first executing the update label given on e1 and then the update label given on e2. v' satisfies Inv(L') Either  ℓ1 or ℓ2 or both locations are committed, or no other location in L is committed.   There is no action transition from (L, v) with a strictly higher priority.  Broadcast Synchronisations Assume an order p1, p2, … pn of processes given by the order of the processes in the system declaration statement. We have a transition (L, v) −*→ (L', v') if there is an edge e=(ℓ,ℓ') and m edges ei=(ℓi,ℓi') for 1≤i≤m such that:\n Edges e, e1, e2, …, em are in different processes. e1, e2, …, em are ordered according to the process ordering p1, p2,… pn. e has a synchronisation label c! and e1, e2, …, em have synchronisation labels c?, where c is a broadcast channel. v satisfies the guards of e, e1, e2, … em. For all locations ℓ in L not a source of one of the edges e, e1, e2, … em, all edges from ℓ either do not have a synchronisation label c? or v does not satisfy the guard on the edge. L' = L[ℓ'/ℓ, ℓ1'/ℓ1, ℓ2'/ℓ2, … ℓm'/ℓm] v' is obtained from v by first executing the update label given on e and then the update labels given on ei for increasing order of i. v' satisfies Inv(L') Either  one or more of the locations ℓ, ℓ1, ℓ2, … ℓm are committed, or no other location in L is committed.   There is no action transition from (L, v) with a strictly higher priority.  Probabilistic Transitions  In statistical model checking the concrete delay and transition are determined as follows:\n Each process chooses a delay based on its current location:  If the current location invariant has a time bound, then the concrete delay is taken according uniform distribution up to that bound. Otherwise (the time invariant is absent) the delay is chosen by exponential distribution using the rate λ specified on the current location. The probability density function of delay d∈[0;∞) is F(d)=λe−λd, where e=2.718281828… and the concrete delay is generated by −ln(u)/λ where u is a uniform random number from (0;1] interval.   The process with the shortest delay is chosen. If there are several such processes then a random one of these is chosen (according to uniform distribution). The shortest delay is executed and continuous variables are updated. The chosen process attempts to take a transition:  Compute all enabled internal and sending edge-transitions. Pick the concrete edge according to uniform distribution. If the edge has probabilistic branches, then the probability of taking a branch i is determined by the ratio wi/W, where wi is the weight of the branch i and W is the sum of all branch weights: W=Σjwj.    Statistical model checking has the following assumptions about the model:\n Input enableness (non-blocking inputs): Sending cannot be blocked, i.e. the channel is either broadcast or there is always one process with an enabled receiving edge-transition. Input determinism: There is exactly one enabled receiving edge-transition at a time. For binary synchronizations there is at most one receiving process at a time.  For more details about probabilistic semantics of priced timed automata please see:\n Statistical Model Checking for Networks of Priced Timed Automata, Alexandre David, Kim G. Larsen, Axel Legay, Marius Mikučionis, Danny Bøgsted Poulsen, Jonas van Vliet and Zheng Wang. In Proceedings of the 9th International Conference on Formal Modeling and Analysis of Timed Systems (FORMATS), Aalborg, Denmark, September 2011.\n "},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/symbolic-simulator/symbolic-traces/","title":"Symbolic Traces","tags":[],"description":"","content":"Since clocks range over the non-negative reals, timed automata can have infinitely many states (not to be confused with locations) and infinitely many traces. The simulator cannot visualize all these concrete traces. Instead it shows an infinite set of traces - a so called symbolic trace. Each symbolic state of a symbolic trace is a set of states and their delay successors described by a number of constraints on the clocks. In a given symbolic state, the active locations and the values of discrete variables are the same for all states.\nSymbolic traces shown in the simulator are backward stable, but not forward stable:\n **Forward stable** Given two symbolic states A and B on a symbolic trace such that A is before B, every state in A can reach a state in B. **Backward stable** Given two symbolic states A and B on a symbolic trace such that A is before B, every state in B can be reached by a state in A.  In particular, care must be taken when interpreting a counter example produced by the model checker: Not every state in the symbolic states along a symbolic trace will necessarily lead to an error state, although all states in the last symbolic state are indeed reachable from the initial state.\nNote: verifyta can be used to produce forward stable traces.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/verifier/","title":"Verifier","tags":[],"description":"","content":"The verifier is to check safety and liveness properties by on-the-fly exploration of the state-space of a system in terms of symbolic states represented by constraints. The verification tool in UPPAAL also provides a requirement specification editor for specifying and documenting the system requirements.\nIn this help section we describe how to operate the verification tool, in terms of how to specify and verify requirements. The requirement specification language and the verification options are described in separate sections.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/gui-reference/yggdrasil/","title":"Test Cases (Yggdrasil)","tags":[],"description":"","content":"Yggdrasil (Test Cases tab) is an offline test-case generation tool with a purpose of increasing edge coverage. It generates traces from the model, and translates them into test cases based on test code entered into the model on edges and locations next to comments. Yggdrasil expects a deadlock free and mostly deterministic model.\nDeadlocks can be checked against in the Verifier tab using A[] not deadlock query.\nThere are no checks or reinforcements made for determinism. Non-deterministic implementation requirements (behavior not controlled by a test execution harness) may yield test-cases which cannot be executed in a controlled manner. For example, test execution harness might not be able to force the implementation under test to respond in a specific way assumed by a test case if the implementation is allowed to respond in multiple ways non-deterministically. The environment assumption model (edges controlled by the test execution harness) is encouraged to be non-deterministic to facilitate a more focused and flexible control when selecting test cases.\nThe buttons \u0026ldquo;Add\u0026rdquo; will generate traces based on the verification options selected in the Options menu where the search order and diagnostic trace options are overridden by the corresponding drop-down list selection. The traces are added and shown in the Traces list below on the left. Selecting a trace will show the statistics for this trace in the Trace statistics on the right. The \u0026ldquo;Total Coverage\u0026rdquo; button will show the combined statistics of all the traces added so far. Double clicking a trace loads the trace in the Simulator tab, where the execution scenario can be examined in detail. Simulator colors the covered locations and edges in blue when \u0026ldquo;Mark Visited\u0026rdquo; option is selected under the View menu.\nTest cases are exported to a specified directory specified by clicking \u0026ldquo;Export code\u0026rdquo; button at the bottom. Previously stored test cases are overwritten by new test ones.\nNote: the traces and statistics are lost when the model is reloaded. Traces and statistics are not saved with the model. Only the test cases can be saved.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/","title":"","tags":[],"description":"","content":"UPPAAL Help UPPAAL is a tool for modeling, validation and verification of real-time systems. It is appropriate for systems that can be modeled as a collection of non-deterministic processes with finite control structure and real-valued clocks (i.e. timed automata), communicating through channels and (or) shared data structures. Typical application areas include real-time controllers, communication protocols, and other systems in which timing aspects are critical.\nThe UPPAAL tool consists of three main parts:\n a graphical user interface (GUI), a verification server, and a command line tool.  The GUI is used for modelling, symbolic simulation, concrete simulation, and verification. For both simulation and verification, the GUI uses the verification server. In simulation, the server is used to compute successor states. See also the section on setting up a remote server. The command line tool is a stand-alone verifier, appropriate for e.g. batch verifications.\nMore information can be found at the UPPAAL web site: http://www.uppaal.org.\n"},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://uppaalmodelchecker.github.io/docs.uppaal.org/tags/","title":"Tags","tags":[],"description":"","content":""}]